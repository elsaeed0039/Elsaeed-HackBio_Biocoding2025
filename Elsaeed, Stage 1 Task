#HACKBIOCODING INTERNSHIP

#STAGE 1

#Function for translating DNA to protein


def translate_dna_to_protein(dna_sequence):
    # Define the codon to amino acid mapping (genetic code)
    codon_table = {
        'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M',
        'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
        'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K',
        'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',
        'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L',
        'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
        'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q',
        'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
        'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',
        'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
        'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E',
        'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
        'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S',
        'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',
        'TAC':'Y', 'TAT':'Y', 'TAA':'_', 'TAG':'_',
        'TGC':'C', 'TGT':'C', 'TGA':'_', 'TGG':'W',
    }

    # Initialize the protein sequence
    protein_sequence = ""

    # Iterate over the DNA sequence in steps of 3 (codon length)
    for i in range(0, len(dna_sequence), 3):
        codon = dna_sequence[i:i+3]
        if codon in codon_table:
            protein_sequence += codon_table[codon]
        else:
            protein_sequence += "X"  # Placeholder for unknown codon

    return protein_sequence

# Example usage
dna_sequence = "ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG"
protein = translate_dna_to_protein(dna_sequence)
print("Protein sequence:", protein)



#Function for calculating the hamming distance between your Slack username and twitter/X handle 

def hamming_distance(str1, str2):
    # Ensure the strings are of equal length
    if len(str1) != len(str2):
        raise ValueError("Strings must be of equal length to calculate Hamming distance")
    
    # Calculate the Hamming distance
    distance = sum(1 for x, y in zip(str1, str2) if x != y)
    
    return distance

# Define the Slack username and Twitter handle
slack_username = "Elsaeed003"
twitter_handle = "Elsaeed004"

# Calculate the Hamming distance
distance = hamming_distance(slack_username, twitter_handle)
print("The Hamming distance is:", distance)




#Function that simulates and generates a logistic population growth curve "the function also include 2 extra parameters that randomize the length of the lag phase and the exponential phase"
# Function are used to  generate a data frame with 100 different growth curves
# Function are used to determining the time to reach 80% of the maximum growth

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def logistic_growth_curve(initial_population, carrying_capacity, growth_rate, total_time, lag_phase_range, exp_phase_range):
    # Create time array
    time = np.linspace(0, total_time, 500)
    
    # Generate random lengths for lag phase and exponential phase
    lag_phase_length = np.random.uniform(lag_phase_range[0], lag_phase_range[1])
    exp_phase_length = np.random.uniform(exp_phase_range[0], exp_phase_range[1])
    
    # Create an array to hold population values
    population = np.zeros_like(time)
    
    for i, t in enumerate(time):
        if t < lag_phase_length:
            # Lag phase: population remains nearly constant
            population[i] = initial_population
        else:
            # Logistic growth phase
            relative_time = t - lag_phase_length
            exponent = -growth_rate * (relative_time - exp_phase_length)
            population[i] = carrying_capacity / (1 + (carrying_capacity / initial_population - 1) * np.exp(exponent))
    
    return time, population


# Define parameters
initial_population = 10
carrying_capacity = 1000
growth_rate = 0.2
total_time = 50
lag_phase_range = (5, 10)
exp_phase_range = (5, 10)

# Create an empty dataframe
df = pd.DataFrame()

# Generate 100 different growth curves
for i in range(100):
    time, population = logistic_growth_curve(initial_population, carrying_capacity, growth_rate, total_time, lag_phase_range, exp_phase_range)
    df[f"Population_{i+1}"] = population

df["Time"] = time
df.set_index("Time", inplace=True)



def time_to_reach_80_percent(population, carrying_capacity):
    target_population = 0.8 * carrying_capacity
    for t, pop in enumerate(population):
        if pop >= target_population:
            return t
    return None  # Return None if 80% carrying capacity is never reached

# Example usage for one of the growth curves
time_index = time_to_reach_80_percent(df["Population_1"].values, carrying_capacity)
print(f"Time to reach 80% of the maximum growth for Population_1: {df.index[time_index]}")

# If you need to find this for all growth curves
times_to_80_percent = {f"Population_{i+1}": df.index[time_to_reach_80_percent(df[f"Population_{i+1}"].values, carrying_capacity)]
                       for i in range(100)}

print(times_to_80_percent)

 
